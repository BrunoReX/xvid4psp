#############################################################################
## Note: The English parameter description you can find in the avs files!! ##
#############################################################################

Mrestore und Cdeblend

---------------
Basis
---------------
	Um die Funktionen benutzen zu koennen, lade die Funktion mit import("Mrestore.avs")
	bzw. import("Cdeblend.avs") in dein Skript.
	Man benoetigt die letzte Masktools 2.0 und TIVTC 1.04 (oder hoeher) Version um alle Einstellungen nutzen zu koennen.
	Moechte man 'fnr' nutzen wird zudem noch RemoveGrain benoetigt.

	Version:	- mrestore v2.3b  - 06.12.2007
			- Cdeblend v1.1b  - 19.12.2006

----------------
mrestore
----------------
	
	--------
	Gebrauch
	--------
	code:	bobbed (or progressive) source

		mrestore()


		------
		or:

		ord = last.getparity() ? 1 : 0

		leakkernelbob(ord,4,true,true)

		mrestore(dclip=last.crop(8,8,-16,-8))


		------
		or:

		d = last.bob(-0.2,0.6).reduceflicker(strength=1)	#Didee use this in restore24

		tdeint(mode=1)						#or for example yadif(mode=1)

		mrestore(mode=-4,dup=1,dclip=d)


	Parameter:

	function mrestore(clip clp, int "numr", int "denm", int "mode", float "bf", bool "chroma", int "dup", int "cache", float "rx", float "ry", int "mthr", clip "dclip")

		numr/denm
			Fuer die typischen Normwandlungen werden die Dezimierungsparameter nicht benoetigt, bei einigen seltener auftretenen Faellen
			man die Dezimierungswerte jedoch erstmal berechnen.
			Mrestore verwendet den Numerator und Denominator anstelle eines einzigen Parameters fuer die Ausgabeframerate, weil diese Methode
			genauer ist.
			Wenn dir die richtige Ausgangsframerate bekannt ist, kannst du die richtigen Werte mit den folgenden drei Regel berechnen:
				1) numr und denm sind positive ganze Zahlen
				2) Eingangsframerate * numr = Ausgabeframerate * denm
				3) (Ausgabeframerate * x) / (Eingangsframerate * x) = numr / denm 	= gekuerzter echter Bruch
				
			=> ein guter Startwert fuer 'x' ist haeufig der Wert 2002. 
			- Beispiel:  59.94fps -> 25fps
				numr = output framerate * 2002 = 25 * 2002 = 50050
				denm = input framerate * 2002 = 59.94 * 2002 = (60000 / 1001) * 2002 = 120000
				numr / denm = 50050 / 120000 = 1001 / 2400
				=> numr = 1001, denm = 2400

		mode
			Nachdem man die richtigen Dezimierungsparameter eingegeben hat, kann nun der Erkennungmodus von mrestore festgelet werden.
			      0		- langsamer als 3-6 aber meist am besten, kann auch Partikularblends erkennen
			      1/2	- wie mode 0, aber mit geringere block groesse, nuetzlich fuer hoehere rx/ry Werte bei hochaufloesenden Material
			      3		- gute Blenderkennung + Extraerkennung fuer Szenen mit sehr wenig Bewegung, schneller als mode 0-2
			      4		- wie mode 3, aber ohne Extraerkennung, ewas schneller
			      5		- keine Blenderkennung, nur Dezimierung
			      
   			Default - 3
   			
		bf
		  	Der Blend Faktor dient zur Gewichtung der Blenderkennung gegenueber den Werten der Dezimierungsroutine.
		  	Default - 0.6	(recommed: 0.1-10.0)
			
		chroma
 		      	Mit chroma=true arbeitet mrestore auch mit den Farbkanaelen. Die Erkennung wird dadurch langsamer, unter Umstaenden aber auch besser.
  			Default - false
  	
		dup
		  	Der Parameter 'dup' kennt nur drei Zustaende:
		  	      <0	- die Quelle hat ueberall volle Bildrate, es gibt keine Duplikate
			      0		- es sind viele Duplikate und/oder Szenen ohne Bewegung in der Quelle
			      >0	- das Video ist animiert oder gezeichnet worden und besitzt viele doppelte Frames mit unterschiedlicher Qualitaet
			Dup hat keinen Einfluss auf die Geschwindigkeit von Mrestore. Dup>=0 aktiviert eine Bewegungserkennung die zur Verbesserung der
			Dezimierung von animierten (gezeichneten usw.) Quellen fuehrt. Mit dup>1 kann man die Komprimierbarkeit des Videos erhoehen, da
			viele sehr aehliche Frames zu richtigen Duplikaten werden.
			Default - 0

  		cache
  		     	Mit cache>=0 wird RequestLinear verwendet um auch bei nicht-linearen Frameabruf nicht aus den Pattern zu fallen. Du kannst die Anzahl
    			der zwischengespeicherten Frames festlegen. Bei negativen Werten wird RequestLinear nicht mehr verwendet 
    			(kann bei Speicherproblemen nuetzlich sein).
    			Default - 5
    			
		rx/ry
			Die Radii zur Groessenreduzierung des Erkennungsclips.
			Default - 3.0	(recommed: 2.0 - 4.0)
			
		mthr
		    	Die Bewegungsberechnung kann nur gering gesteuert werden. Es sind nur Werte zwischen -8 und 8 erlaubt. Setzt mann einen anderen Wert,
  			so wird automatisch der Standardwert verwendet.
			Kleinere Werte bedeuten, dass weniger Frames als Duplikate erkannt werden.
		    	Default - 0

		dclip
			Natuerlich kann man auch in dieser Version wieder einen eigenen Erkennungsclip verwenden, entweder um die Erkennung etwas zu beschleunigen
			und mit Hilfe von anderen Filtern leicht zu verbessern.



----------------
Cdeblend
----------------
	Verglichen mit unblend, deblend oder auch removeblend ist diese Funktion etwas langsamer
	und wegen dem "conditional enviroment" nicht so stabil und kompatibel, dafür ist sie in
	vielen Bereichen recht brauchbar, besonders da wo unblend mal nicht so viel erkennt.

	--------
	Gebrauch
	--------
	code:	bobbed (or progressive) source

		Cdeblend()

		------
		or:

		tdeint(mode=1)

		c = last.crop(8,16,-8,-8)

		Cdeblend(dlip=c,omode=1)

		------
		or:

		ord = last.getparity() ? 1 : 0

		leakkernelbob(order=ord)

		Cdeblend(dlip=last.crop(18,24,-14,-16))



	Parameter:

		omode
			Steht für "output mode".
			omode 0 ->	Das vorherige Frame wird an Stelle des Blends gewaehlt (dupliziert).
					-> Standard
			omode 1 ->	Das naechste Frame wird genutzt.
			omode 2 ->	Wie omode 0 aber mit Code zur Erkennung von doppelten Blends 
					(nur wenn alle Frames vorhanden)
			omode 3 ->	Ist ein spezieller Mode für 12fps Quellen. Es gibt nur die Frames mit den
					geringsten Blendwahrscheinlichkeiten aus.
			omode 4 ->	Tut nichts mit der Quelle außer den errechneten Blendwert mit auszugeben.

		bthresh
			Fuer omode 0 und 1 wird bthresh einfach mit dem errechneten Blendwert verglichen. Ist bthresh
			kleiner als der Blendwert, wird das Frame als Blend erkannt. Omode 3 nutzt diesen Threshold
			um klare Frames zu erkennen. Ist der errechnete Blendwert kleiner als der negative bthresh-Wert,
			dann wird das Frame ausgegeben, auch wenn es unter den herangezogenen Frames noch einen kleineren
			Blendwert gibt. Dies soll bei 24fps Anteile einer 12fps Source fuer fluessigere Bewegungen sorgen.
			Default:	0.1	[0 ... 2.0]

		mthresh
			Entspricht einem einfachen Bewegungsthreshold. Liegen die Framedifferenzen unter dem gesetzten
			Wert, werden an dieser Stelle keine Blends erkannt, der Pattern wird trotzdem fortgesetzt.
			Standard - 0.6	(Wertebereich: 0.3-1.6)

		
		xr,yr,fnr
			Ab der 1.5 Beta Version von Mrestore gibt es die Moeglichkeit mit diesen drei Parametern den Clip
			zur Blenderkennung für diese Aufgabe leicht zu veraendern ohne explizit den 'dclip' setzen
			zu muessen. Die beiden Radien (xr und yr) verringern die Aufloesung und ermoeglichen so haeufig eine
			etwas schnellere Erkennung. Zudem wird dadurch auch der Einfluss des Deinterlacers und vom Rauschen
			der Quelle verringert. Mit "fnr=true" aktiviert man einen schnellen (aber auch sehr einfachen)
			Denoiser. Das hilft besonders bei verrauschten Quellen in denen die eigentliche Bewegung nur einen
			kleinen Bereich des Bildes betrifft (Anime). Will man dieses Feature nutzen, sollte man die Radien nicht zu 
			gross waehlen um zu starkes Bearbeiten zu vermeiden. Bei guten Quellen, also bei gut verteilten Bewegungen
			und wenig Rauschen sollte man 'fnr' nicht nutzen (neben den geringen Geschwindigkeitsverlust hat ein
			so einfachen Denoiser natuerlich noch andere Nachteile).
			Standard	- xr: 1.5
					- yr: 2.0	(hoeher als xr aufgrund der geringeren Aufloesung wegen dem Deinterlacing)
					- fnr: false
