
<!-- saved from url=(0049)http://dw.school2.ru/doc/ixbt/deshaker_guide.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">

<title>Руководство по фильтру Deshaker</title>
<style>
</style>
</head><body>
<h1>Руководство по использованию фильтра Deshaker</h1>
<p>Это руководство частично основано на статье <a href="http://www.sundancemediagroup.com/articles/deshaker_guide.htm">John Meyer “A guide to using Deshaker”</a>, 
некоторые несущественные разделы пропущены, зато добавлены комментарии:) Официальная документация находится 
<a href="http://www.guthspot.se/video/deshaker.htm">здесь</a>,
имеется <a href="http://alvator.narod.ru/articles/deshaker/description.htm">русский перевод</a>, выполненный <b>TAB</b>. </p>
<p>Данная статья описывает версию Deshaker 1.4 от 2005 года; более полное описание Deshaker и расширенное исследование, посвящённое стабилизации видео, вы можете найти <a href="http://dw.school2.ru/doc/ixbt/stabilization.html">здесь</a>.
</p><p>Предполагается, что вы знакомы с программой VirtualDub и смогли <a href="http://www.guthspot.se/video/files/Deshaker.zip">загрузить</a> 
и установить сам плагин Deshaker.vdf, а также прочитать документацию к нему.</p>
<h2>Введение</h2>
<p>Deshaker – это лучший из общедоступных на сегодняшний день стабилизаторов видео. Принцип его работы заключается в 
следующем. <br>Фильтр работает в два этапа. На первом этапе происходит определение движения в кадре, сходным образом с тем, 
как работают MPEG-подобные кодировщики, а именно: кадр разбивается на [квадратные] блоки, для каждого блока ищется 
соответствующий ему блок в предыдущем кадре и вычисляется вектор смещения этого блока относительно соответствующего 
блока предыдущего кадра. На малоконтрастных участках изображения, как правило, трудно установить однозначное 
соответствие между блоками, поэтому часть векторов смещения может оказаться неопределённой. После того, как смещения
всех подходящих блоков этого кадра найдены, для кадра вычисляется четыре величины, характеризующие его движение 
относительно предыдущего кадра: сдвиг центра по горизонтали, вертикали, поворот и изменение масштаба. Эти величины 
записываются в LOG-файл. <br>На втором этапе по этому LOG-файлу вычисляется траектория движения камеры, имевшая место 
при съёмке, и сглаженная траектория, которую хочется получить в результате стабилизации. Далее каждый кадр смещается, 
поворачивается и масштабируется в соответствии с желаемой траекторией движения. Естественно, что при этом участки на краю
полученного кадра могут отсутствовать в исходном кадре, в этом случае они берутся из соответствующих областей 
предыдущих и последующих кадров (тоже соответствующим образом смещённых). Как правило, если на краю кадра не было 
движущихся объектов, то такое добавление информации из соседних кадров не создаёт артефактов. 
<br>Таким образом, два основных преимущества Deshaker – это работа в два этапа, что позволяет заранее просчитать 
траекторию камеры и необходимые поправки, и возможность использования информации из соседних кадров для добавления 
недостающих участков по краям изображения. Ещё одно преимущество для опытных пользователей – наличие множества настроек
и возможность вручную редактировать LOG-файл для исправления ошибок детектора движения на отдельных кадрах.</p>
<h2>Краткое руководство</h2>
<p>Загрузите клип в VirtualDub и добавьте фильтр Deshaker. В настройках необходимо установить следующие параметры:</p>
<ol>
<li><p><var>Source Pixel Aspect</var> (пропорции пикселя исходного видео) – установите соответственно с типом 
источника видео. Для miniDV это будет Standard PAL (1.094) или Standard NTSC (0.911).</p></li>
<li><p><var>Video Type</var> (тип видео) – бывает прогрессивным или чересстрочным, в последнем случае необходимо 
указать порядок полей. Для большинства miniDV камер нужно ставить Interlaced, Lower field first; для съёмок в 
прогрессивном режиме – None (Progressive).</p></li>
<li><p><var>Log file</var> (имя LOG-файла) – я предпочитаю не хранить их в корневом каталоге диска C :-)</p></li>
<li>В секции <b>Pass 1</b> можно ничего не трогать, но для более качественного анализа движения можно поставить 
<var>Scale</var>=Full и <var>Use pixels</var>=All. Однако это замедляет работу первого прохода в 2-4 раза. <p></p></li>
<li><p>В секции <b>Pass 2</b> выставляем <var>Destination pixel aspect</var> такой же, как <var>Source pixel aspect</var>, 
и желаемый размер кадра (вероятно, лучше ставить такой же, как исходный кадр – 720x576 для PAL miniDV, 720x480 для NTSC 
miniDV).</p></li>
<li><p>Включите галку “<var>Use previous and future frames...</var>”, числа можно оставить по умолчанию</p></li>
<li><p>Значения в секции <var>Motion smoothness</var> можно увеличить в несколько раз относительно значений по 
умолчанию. При больших величинах (более 10000), впрочем, движение может выглядеть неестественно.</p></li>
<li><p>Значения <var>Max correction limits</var> можно не трогать, хотя John Meyer рекомендует выставить их в максимум 
(99)</p></li>
<li><p>Наконец <b>(важно!)</b>, щёлкните обратно вкладку <b>Pass 1</b> и жмите OK.</p></li>
</ol>
<p>Теперь необходимо запустить первый проход фильтра. Перемотайте в начало клипа кнопкой <b>(|&lt;)</b> и запустите 
проигрывание выходного видео кнопкой <b>(&gt;O)</b> (или запустите Preview клавишей F5). Откиньтесь на спинку кресла, 
как говорится.. первый проход занимает достаточно много времени. Тем не менее бывает полезно пронаблюдать за работой 
фильтра на этом этапе. Он выдаёт в правом окошке ккадр с наложенными на него векторами смещения для блоков (если видео 
чересстрочное, то два поля одного кадра располагаются друг под другом). Внизу каждого поля информационная строчка 
показывает найденные величины смещения, поворота и масштабирования. Если строчка красная со значениями “0, 0, 0, 1”, то 
дело не в порядке – в этом кадре оказалось слишком мало подходящих для анализа движения блоков. Вполне возможно, что на 
этом месте будет скачок при стабилизации. О способах борьбы с этим см. ниже в детальных настройках.<br>
Когда первый проход закончен, не нажимая никаких клавиш движения и перемотки, зайдите в меню Filters, вновь выберите Deshaker
и нажмите вкладку <b>Pass 2</b>. Поскольку все настройки второго прохода мы уже сделали, можно нажимать OK и запускать
второй проход. При первом нажатии клавиш перемотки Deshaker выдаст табличку с предупреждением, что требуется некоторое время 
для стабилизации видео (оно зависит от настроек плавности движения, но обычно составляет малую долю от продолжительности 
второго прохода, который, в свою очередь, быстрее, чем первый). Также вам стоит выставить видео кодек, если вы ещё этого не 
сделали. Итак, нажимайте “Save as avi” и скоро стабилизированный видеоклип будет готов.</p>
<h2>Советы по использованию</h2>
<ol>
<li><p>Легко заметить, что в полученном файле в начале идёт некоторое количество чёрных кадров с надписью, а в конце такое же 
количество кадров обрезано, при этом звук остался на месте, а значит, сдвинут относительно изображения. Если внимательно 
почитать эту надпись, то станет ясно, что для звука нужно задать задержку (в меню Audio/Interleaving пункт “Delay audio track
by ... ms”, число миллисекунд фильтр подсказывает). Это происходит потому, что внутренний интерфейс работы VirtualDub с 
фильтрами не предусматривает выдачу кадров с опережением, что необходимо для Deshaker'овского метода восстановления краёв 
изображения по данным предыдущих/следующих кадров. Поэтому, если задано ненулевое число N “следующих” кадров, то Deshaker 
задерживает выдачу изображения на N кадров, помещая их во внутренний буфер. Чтобы компенсировать эту особенность и получить
выходной файл с тем же количеством содержательных кадров, что и входной, нужно на втором проходе применить такой метод:</p><ul>
<li><p>Добавить к видеоряду ещё какой-нибудь файл (Append avi segment); какой именно, неважно, главное, чтобы в нём было 
не меньше N кадров и при этом параметры файла (размер кадра, тип сжатия и т.д.) были такими же. Можно использовать и сам
исходный файл.</p></li>
<li><p>Задать задержку звука, как описано выше. Задать диапазон кадров (Video/Select range) такой: Start offset=N (кадров, 
а не миллисекунд!), длина Lenght равна длине исходного клипа (её нужно запомнить перед добавлением Avi segment).</p></li>
<li><p>Передвинуть курсор на начало клипа и промотать покадрово (стрелкой вправо) ровно N кадров. На последнем шаге 
в правом окне должно появиться изображение вместо чёрного экрана с надписью.</p></li>
<li><p>Нажимать Save as AVI. Внутренний буфер фильтра уже заполнен первыми кадрами, и он сразу начинает выдавать изображение.
</p></li></ul>
<p>Аналогично, для просмотра видео без сохранения требуется промотать вперёд N кадров, прежде чем фильтр начнёт выдавать 
изображение.</p></li>
<li><p>Настройки второго прохода (например, плавность) можно менять для получения желаемого результата, при этом, очевидно, 
нет необходимости прогонять заново первый проход.</p></li>
<li><p>Чтобы не настраивать каждый раз параметры фильтра, можно воспользоваться механизмом Save/Load processing settings 
(меню File). Один раз сохранив настройки, можно при следующем запуске VirtualDub, открыв видеофайл, загрузить эти настройки
(это будут параметры фильтра, кодек, задержка аудио, в общем, всё, кроме имени исходного видеофайла). Может быть, потребуется 
поменять только имя log-файла, если вы предпочитаете сохранять разные log-файлы для разных видеоклипов.</p></li>
<li><p>Если вам нужно обработать в пакетном режиме много видеофайлов, то можно для первого прохода задать установку 
Video output=None (на вкладке Pass 1). Тогда вместо векторов движения выдаётся пустой квадратик 8х8. Соответственно, если в 
пакетном режиме (batch mode) сохранять пустой видеофайл от первого прохода, он не займёт много места. Второй проход
лучше уж делать в ручном режиме, по крайней мере если требуется точное выставление начала/конца клипа, как описано выше.</p></li>
</ol>

<h2>Тонкая настройка</h2>
<p>Расписанные выше установки достаточно хорошо работают в обычной ситуации, когда видео снято с одной точки, трансфокатор 
(zoom) установлен не на минимум, и в кадре не присутствуют объекты значительных размеров, двигающиеся в разных направлениях.
Если вам кажется, что стабилизация недостаточна, можно увеличить значения параметров <var>Motion smoothness</var> на втором проходе.
Я использовал величины до 18000. Однако это имеет и негативную сторону: при слишком больших значениях, если исходное изображение 
было достаточно дёрганым, на краях полученного кадра могут возникать странные явления. Это результат работы алгоритма edge 
compensation, т.е. заполнения нехватающих участков по краям данными из соседних кадров. Если в кадрах были движущиеся объекты 
вблизи краёв изображения, то подстановка участков из соседних кадров будет давать несоответствующее текущему кадру положение
этих объектов относительно фона. Как правило, эти "плывущие" края не будут видны на телевизоре, т.к. на нём края изображения 
обрезаются (приблизительно 5%, так называемый overscan). Однако, если вы предполагаете смотреть видео на мониторе, то можно
применить дополнительное увеличение центральной части кадра (<var>Extra zoom factor</var> установить чуть больше единицы, например, 1.05
или 1.1). Нужно понимать, что при этом мы несколько теряем в разрешении, т.к. некоторая область кадра растягивается на весь кадр.<br>
В общем, установки плавности нужно подбирать в зависимости от "дёрганности" исходного видео - если оно было не сильно дёрганным,
то можно добиться большей плавности, если же нет, то придётся ограничиться некоторым смягчением дёрганий, но полностью 
избавиться от них вряд ли удастся, т.к. повышение плавности будет приводить к слишком большим артефактам на краях кадра.</p>
<p>Если, несмотря на повышение параметров плавности, видео всё равно дёргается, то, вероятнее всего, это вызвано неправильным 
определение движения на первом проходе. К примеру, если вы ведёте камеру вслед за большим движущимся объектом, то алгоритм
поиска движения не сможет корректно отделить движущийся фон от движущегося в другом направлении объекта, который занимает 
значительную часть кадра. Вектора движения блоков будут направлены в разные стороны, и в зависимости от того, каких оказалось 
больше, движение всего кадра будет определяться то по фону, то по объекту. Разумеется, при попытке стабилизировать полученный
видеоряд мы увидим дёргание картинки. <br>
Чтобы исправить положение, нужно явным образом указать программе, какая часть кадра движется за счёт движения камеры (т.е.
является фоном, и именно его движение чаще всего надо стабилизировать), а какая - сама по себе. Для этого в Deshaker имеется
семейство параметров <var>Ignore image area</var>. Чтобы исключить из рассмотрения объект в середине кадра, установите параметры 
в строке <var>inside</var>: к примеру, вы хотите оставить только верхнюю и нижнюю четверти экрана, введите 144 (=высота
кадра/4) в поля <var>Top</var> и <var>Bottom</var>. Возможна ситуация, когда, наоборот, нужно рассматривать только центральную 
часть кадра, тогда задайте значения в строке <var>outside</var>. Эту область легко контролировать при просмотре первого прохода: 
игнорируемая область закрашивается чёрным. Нужно, однако, следить за тем, чтобы в оставшейся части кадра было достаточно блоков 
с определяемыми векторами движения. Возможно, следует уменьшить размер блока, задаваемый параметром <var>Block size</var> 
(по умолчанию 30), только при этом ещё нужно установить <var>Use pixels=All(most robust)</var>.</p>

<p>Если вы снимаете движущейся камерой, такое видео гораздо труднее поддаётся стабилизации (разумеется, это представляет 
сложность не только для Deshaker'а, но и для любого другого подобного программного стабилизатора). Тем не менее, Deshaker
достаточно хорошо работает и в этом случае. В таких ситуациях может помочь параметр <var>“Discard Motion of Blocks That 
Move &gt;x Pixels in the Wrong Direction”</var>, который управляет отбраковкой блоков, движущихся не в том направлении.
Можно попробовать поднять его значение с 5 до, скажем, 15 или даже 30. Действие этого параметра видно на первом проходе: 
в случае нетривиального движения камеры блоки в кадре могут двигаться в самых различных направлениях. Красные вектора движения
обозначают блоки, которые двигаются не в том направлении, что большинство блоков (а именно, вектор движения блока отличается 
как раз на <var>x</var> пикселей от среднего вектора движения для этой области кадра). По-хорошему, красные стрелки должны
быть как раз у тех блоков, которые действительно принадлежат движущимся объектам в кадре, а те области, движение которых вызвано 
движением самой камеры, должны иметь белые вектора, в этом случае движение камеры определяется достаточно уверенно. Этот 
параметр и призван в какой-то степени управлять отбраковкой ненужного движения. Кстати, в обычном случае достаточно плавного
движения автор фильтра рекомендует уменьшить этот параметр до 1 (на мой взгляд, довольно спорно).<br>
Параметры из группы <var>“Ignore Image Area”</var> также могут использоваться в случае движения камеры: например, если вы 
снимаете пейзаж из окна автомобиля, то в нижней части кадра, вероятно, ннаходятся быстро движущиеся объекты ближнего плана, 
а в верхней - практически неподвижный дальний план, и можно пытаться привязываться именно к нему.<br>
Также можно попытаться поиграть параметром <var>“Discard motion of blocks that have match value &lt;...”</var>: попробуйте
увеличить его с 300 до 500 или 600. Если не поможет, попробуйте уменьшить до 100-150.. Этот параметр вместе со следующим 
(<var>Discard blocks that have 2nd best match &gt; best-...</var>) управляет отбраковкой блоков в малоконтрастных участках 
изображения. Уменьшая их, вы увеличиваете количество блоков с определяемым движением, но при этом в таких малоконтрастных
областях (небо, облака, или даже поверхность воды) движения блоков могут определяться некорректно. Впрочем, неправильно 
определённые вектора движения отбрасываются параметром <var>...move &gt; pixels in wrong direction</var>. По собственному опыту,
если в кадре слишком мало определённых блоков, то стоит уменьшать два вышеназванных параметра, чтобы увеличить их число
(особенно если блоков настолько мало, что Deshaker не считает возможным достоверно определить по ним движение всего кадра.
Это происходит, если их меньше 5% (по умолчанию; регулируется параметром <var>Skip frame if &lt;x% of blocks are OK</var>),
при этом на первом проходе строка статуса красная. В этом случае обязательно надо попытаться уменьшить "критичность" 
детектора движения для блоков, хотя можно и уменьшить порог отбрасывания всего кадра, иначе почти наверняка в этом месте 
возникнет скачок в полученном видео. Хотя если переборщить с параметрами, то случайные движения малоконтрастных блоков внесут
большие помехи в результирующее движение кадра. </p>

<p>В конце концов, ничто не мешает разные куски клипа обрабатывать с разными установками (например, если движущийся объект, 
который нужно проигнорировать, находится то в левой, то в правой частях кадра), а полученные LOG-файлы склеить в обычном
текстовом редакторе. Если же отдельные кадры никак не поддаются разумному определению движения, то самый простой вариант -
исправить для них значения в LOG-файле руками. Например, задать такими же, как у соседнего кадра.
В каждой строке LOG-файла содержится информация об одном кадре или (для чересстрочного видео) об одном поле: смещение по X, по Y,
поворот и увеличение.</p>

<h2>Ограничения стабилизации</h2>
<p>Как правило, движение камера, также как и движение отдельных объектов в камере, создаёт эффект "motion blur", или размытие
в движении. Это проявляется в том, что объекты размыты вдоль направления смещения. Глаз не замечает этого на быстро движущихся
объектах, но если вы стабилизируете видео, то такие области кадра будут казаться расфокусированными, а из-за того, что скорость 
движения меняется от кадра к кадру, эта расфокусировка ещё и будет "плавать" по амплитуде. Это может выглядеть довольно неприятно, 
но, к сожалению, не поддаётся исправлению. Вам решать, какое видео смотреть менее неприятно: дёрганное или расфокусированное.<br>
Тем не менее, если ваша камера позволяет регулировать скорость затвора, и вы планируете пользоваться программной стабилизацией,
то стоит установить скорость затвора меньше обычной (хотя бы 1/100 с, а лучше 1/200; меньше, как правило, не требуется).</p>

<h2>Выводы</h2>
<p>Deshaker - очень гибкий и мощный инструмент для устранения дрожания видео. Обычные установки хорошо работают для большинства
случаев; если же хочется большего, то и для тонкой настройки полно возможностей.</p>
<p>С пожеланиями творческих успехов, <br>
Евгений Васильев (eugvas<span>@</span>mccme.ru)<br>
Last-update: июль 2005.</p>



</body></html>